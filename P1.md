# Mimicus - Comprehensive Feature Implementation Plan
## Phases 1-2 + Stage 9 (State Management)

## Executive Summary

Implement comprehensive mock service enhancements following HLD Phase 1 & 2:

**Delivery Order** (by HLD phases):
1. **Phase 1** (Weeks 1-3): Admin UI, Request Inspector, Error Simulation, Rate Limiting, Random Data Helpers
2. **Stage 9** (Weeks 1-3, foundational): SQLite State Management (prerequisite for Phase 1)
3. **Phase 2** (Week 4): Recording & Variants (advanced features)

**Key Architecture Decision**: Use SQLite (existing database) for state storage instead of Redis (can add Redis later for caching/performance optimization)

---

## Stage 9: SQLite State Management (Foundation)

### Overview

Implement persistent state management scoped by session/client context. This enables:
- Session-based state (counters, user context, sequential IDs)
- Client-scoped state (per IP address)
- Atomic operations (get, set, increment, delete)
- Integration with Jinja2 templates (`{{ state.get(key) }}`)
- Admin API for inspecting/managing state

### Critical Files - Stage 9

**New Files (6 total, ~650 lines)**:
1. `src/domain/entities/state.py` - State entity (50 lines)
2. `src/domain/repositories/state_repository.py` - Repository interface + implementations (70 lines)
3. `src/domain/services/state_service.py` - State business logic (60 lines)
4. `src/application/dtos/state_dtos.py` - State DTOs (40 lines)
5. `src/application/mappers/state_mapper.py` - DTO ↔ Entity mapping (30 lines)
6. `src/application/use_cases/state_*.py` - CRUD use cases (6 files, ~150 lines total)
7. `src/presentation/api/v1/state_api.py` - State endpoints (60 lines)

**Modified Files (5 total)**:
1. `src/infrastructure/database/models.py` - Add StateModel
2. `src/domain/entities/request_context.py` - Add session_id, client_ip
3. `src/domain/services/template_service.py` - Inject state service, expose state in context
4. `src/core/dependencies.py` - Add state repository/service singletons
5. `src/presentation/api/v1/mocks.py` - Extract session/client context

**Test Files (3 total, ~300 lines)**:
- `tests/unit/domain/services/test_state_service.py`
- `tests/integration/test_state_api.py`
- `tests/e2e/test_stateful_flow.py`

---

## Phase 1A: Error Simulation & Rate Limiting

### Overview

Enable mocks to:
- Return errors randomly (configurable error_rate per mock)
- Return 429 Too Many Requests when rate limit exceeded
- Customize error status codes and response bodies

### Critical Files - Phase 1A

**New Files (1 total, ~120 lines)**:
1. `src/domain/services/rate_limiter_service.py` - In-memory rate limiting (120 lines)

**Modified Files (3 total)**:
1. `src/domain/services/response_service.py` - Check error_rate, check rate limits
2. `src/application/dtos/mock_dtos.py` - Add error_status_code, error_rate, error_body fields
3. `src/domain/entities/mock_definition.py` - Add error fields to ResponseConfig

**Test Files (2 total, ~150 lines)**:
- `tests/unit/domain/services/test_rate_limiter_service.py`
- `tests/integration/test_error_rate_and_rate_limiting.py`

---

## Phase 1B: Random Data Generation & Helpers

### Overview

Expand Jinja2 template context with 20+ helper functions:
- Random data: `random_int()`, `random_uuid()`, `random_email()`, `random_phone()`
- Faker integration: `faker.name()`, `faker.address()`, `faker.email()`, etc.
- Sequences: `sequence(key, start=0)` - atomic counter from state
- String/hash: `uppercase()`, `lowercase()`, `md5()`, `sha256()`, `base64_encode()`
- Collections: `sum()`, `min()`, `max()`, `avg()`, `random_choice()`

### Critical Files - Phase 1B

**New Files (1 total, ~150 lines)**:
1. `src/domain/services/template_helpers.py` - All helper functions (150 lines)

**Modified Files (1 total)**:
1. `src/domain/services/template_service.py` - Register all helpers as Jinja2 globals

**Test Files (1 total, ~200 lines)**:
- `tests/unit/domain/services/test_template_helpers.py`

---

## Phase 1C: Request Inspector & Audit Logging

### Overview

Capture all incoming requests and enable debugging:
- Store request method, path, headers, body
- Track which mock matched
- Capture template context and response
- Query by session, mock, or recent requests
- UI to browse request history

### Critical Files - Phase 1C

**New Files (5 total, ~600 lines)**:
1. `src/domain/entities/request_log.py` - RequestLog entity (40 lines)
2. `src/domain/repositories/request_log_repository.py` - Repository interface (50 lines)
3. `src/domain/services/request_log_service.py` - Logging service (60 lines)
4. `src/application/dtos/request_log_dtos.py` - DTOs (50 lines)
5. `src/presentation/api/v1/inspector_api.py` - Inspector endpoints (80 lines)

**Modified Files (3 total)**:
1. `src/infrastructure/database/models.py` - Add RequestLogModel
2. `src/core/dependencies.py` - Add request log service singleton
3. `src/presentation/api/v1/mocks.py` - Log every request

**Test Files (2 total, ~250 lines)**:
- `tests/unit/domain/services/test_request_log_service.py`
- `tests/integration/test_inspector_api.py`

### New API Endpoints

```
GET /api/admin/inspector/requests?session_id=X&limit=50   # List requests
GET /api/admin/inspector/requests/{log_id}                 # Get request details
GET /api/admin/inspector/mocks/{mock_id}/requests          # Requests matched by mock
```

---

## Phase 1D: Admin UI (React SPA)

### Overview

Web interface for managing mocks, inspecting requests, and viewing state.

### Structure

```
/frontend/ or /admin-ui/
  ├── package.json
  ├── vite.config.ts
  ├── src/
  │   ├── pages/
  │   │   ├── MocksPage.tsx       (List & manage mocks)
  │   │   ├── MockEditorPage.tsx  (Create/edit with preview)
  │   │   ├── InspectorPage.tsx   (Request logs)
  │   │   ├── StatePage.tsx       (Session state viewer)
  │   │   └── SettingsPage.tsx
  │   ├── components/
  │   │   ├── MockForm.tsx        (Form with validation)
  │   │   ├── TemplatePreview.tsx (Live Jinja2 preview)
  │   │   ├── RequestLog.tsx      (Request details view)
  │   │   └── StateViewer.tsx
  │   ├── api/
  │   │   └── client.ts           (API client wrapper)
  │   └── types/
  │       └── api.ts              (Type-safe API types)
```

### Key Features

- **Mocks Page**: Search, filter by enabled/mode, quick toggle, edit/delete
- **Mock Editor**: Form with live template preview (calls preview endpoint)
- **Inspector Page**: Timeline of recent requests, filter by session/mock
- **State Page**: Browse session state, inspect counters
- **Settings**: API key management

### Backend Support Files

**New Files (3 total, ~200 lines)**:
1. `src/core/ui_config.py` - UI serving config (40 lines)
2. `src/presentation/api/v1/ui_api.py` - UI support endpoints like template preview (60 lines)
3. Frontend React app (100+ lines React code)

**Modified Files (2 total)**:
1. `src/core/app.py` - Mount static files, serve SPA at /admin
2. `src/presentation/api/v1/admin.py` - Add template preview endpoint

---

## Phase 1 Summary

**Total New Files**: ~20 files (~2,500 lines)
**Total Modified Files**: ~12 files
**Tests**: ~10 test files (~1,200 lines)
**Admin UI**: React SPA (~500+ lines)

**Phase 1 Completion Criteria**:
- ✅ State operations fully functional (get/set/inc/delete)
- ✅ Rate limiting returns 429 on excess
- ✅ Template helpers (faker, random, sequences) work in templates
- ✅ Request inspector shows request/response flow
- ✅ Admin UI loads and displays mocks, state, logs
- ✅ 80%+ test coverage
- ✅ All files under 100 lines

---

## Phase 2: Advanced Features

### Phase 2A: Recording & Capture

**Overview**: Capture real backend responses and auto-create mocks from recordings.

**Files (6 total, ~400 lines)**:
- `src/domain/services/recording_service.py` - Recording orchestration
- `src/application/use_cases/start_recording.py` - Begin recording
- `src/application/use_cases/stop_recording.py` - Stop & capture
- `src/presentation/api/v1/recording_api.py` - Recording endpoints
- Modified: `src/domain/services/proxy_service.py` - Capture responses

**Endpoints**:
```
POST /api/admin/recording/start  # Begin recording
POST /api/admin/recording/stop   # Stop, return captured
GET /api/admin/recording/captured # List captured responses
```

### Phase 2B: Weighted Variants

**Overview**: Multiple response options with probability distribution for A/B testing.

**Files (2 total, ~300 lines)**:
- DTOs: Add variants array to MockResponse
- Modified: `src/domain/services/response_service.py` - Random selection by weight

**Variants Structure**:
```json
{
  "variants": [
    { "weight": 80, "response": { "status": 200, "body": "{...}" } },
    { "weight": 20, "response": { "status": 500, "body": "{...}" } }
  ]
}
```

---

## Implementation Sequence

### Build Order (Respects Dependencies)

1. **Stage 9** - State Management (foundation)
   - State entity → repository → service
   - RequestContext updates
   - Database model, template integration
   - State API endpoints
   - Tests

2. **Phase 1A** - Error & Rate Limiting (independent)
   - TemplateHelpers service
   - Error/rate limiting DTOs
   - Service updates
   - Tests

3. **Phase 1B** - Template Helpers (independent)
   - Register helpers in TemplateService
   - Tests

4. **Phase 1C** - Request Inspector (depends on logging in handlers)
   - RequestLog entity, repository, service
   - Database model
   - Inspector API
   - Mock handler logging
   - Tests

5. **Phase 1D** - Admin UI (depends on all APIs)
   - React app, all pages
   - API client
   - Tests/e2e

6. **Phase 2A** - Recording (depends on Phase 1)
   - Recording service, endpoints
   - ProxyService capture
   - Tests

7. **Phase 2B** - Variants (independent)
   - DTOs, ResponseService updates
   - Tests

---

## Most Critical Files (Implementation Priority)

**These files form the foundation for everything else**:

1. **`src/domain/entities/state.py`** - State entity (new)
   - Why: Foundation for all stateful features; used by templates, state service, repositories

2. **`src/domain/repositories/state_repository.py`** - State repo interface (new)
   - Why: Central abstraction for state persistence; enables multiple backends

3. **`src/domain/services/state_service.py`** - State logic (new)
   - Why: Encapsulates state operations; injected into template service

4. **`src/domain/entities/request_context.py`** - MODIFY
   - Why: Must capture session_id, client_ip for state scoping and rate limiting

5. **`src/domain/services/template_service.py`** - MODIFY
   - Why: Must inject state service + register all helpers

6. **`src/infrastructure/database/models.py`** - APPEND StateModel, RequestLogModel
   - Why: Persistence layer for SQLite backend

7. **`src/core/dependencies.py`** - MODIFY
   - Why: Makes state service available throughout app via DI

8. **`src/domain/services/response_service.py`** - MODIFY
   - Why: Central response generation with error simulation and rate limits

9. **`src/domain/services/template_helpers.py`** - All helpers (new)
   - Why: Centralizes dynamic data generation

10. **`src/presentation/api/v1/mocks.py`** - MODIFY
    - Why: Extract session/client context and log requests for inspector

---

## Success Criteria

### Phase 1 Complete
- State operations fully functional (CRUD)
- Rate limiting returns 429 when exceeded
- Error simulation works (random error_rate)
- Template helpers accessible in templates
- Request inspector shows request/response flow
- Admin UI operational with mock management
- 80%+ test coverage

### Phase 2 Complete
- Recording captures upstream responses
- Variants support probability-weighted selection
- UI shows variant editor

---

## Database Schema Changes

### New Tables

**state** (Stage 9)
```
- state_id (PK)
- state_key (varchar)
- state_value (text/JSON)
- session_id (varchar)
- mock_id (FK)
- client_ip (varchar)
- created_at
- updated_at
```

**request_log** (Phase 1C)
```
- log_id (PK)
- request_method
- request_path
- request_headers_json
- request_body
- matched_mock_id (FK)
- template_context_json
- response_status
- response_body (truncated)
- client_ip
- session_id
- created_at
```

---

## Next Steps

1. **Approve plan** - Confirm approach aligns with your vision
2. **Start Stage 9** - Implement state entity → repository → service → dependencies
3. **Test incrementally** - Unit tests for each layer before integration
4. **Phase 1A-B in parallel** - Error, rate limiting, helpers (independent)
5. **Phase 1C** - Request inspector (depends on logging)
6. **Phase 1D** - Admin UI (last, depends on all APIs being stable)
7. **Phase 2** - Recording and variants (after Phase 1 complete)

---

## Key Architectural Decisions

1. **State Scoping**: By session_id (header) or client_ip (fallback) - enables multi-user testing
2. **Rate Limiting**: In-memory timestamps (not Redis) - simpler, sufficient for MVP
3. **Error Simulation**: Random error_rate per mock - realistic error injection
4. **Request Logging**: All requests (matched & unmatched) with async writes - minimal perf impact
5. **Frontend**: React + TypeScript with vite - type safety, fast dev builds
6. **UI Delivery**: Serve static SPA from FastAPI at /admin - single deployment unit

---

## Estimated Effort

- **Phase 1**: 3-4 weeks (1 developer, with Stage 9 foundation)
- **Phase 2**: 1 week additional
- **Total**: 4-5 weeks for all phases

---

*This plan balances comprehensive feature coverage with architectural integrity, code quality, and testability. All files will be <100 lines with full test coverage.*
